import re
import pandas as pd
import numpy as np

class TransformActions:
    # ... suas outras funções ...

    @staticmethod
    def action_transform_extract_ticket(df: pd.DataFrame, config: dict) -> pd.DataFrame:
        """
        Extrai um valor (issue key) de uma coluna usando regex e escreve em target_column.
        Config esperada:
          - source_column: 'colname' ou {'column': 'colname'}
          - target_column: nome da coluna destino (ex: 'Issue key')
          - pattern: regex (ex: r"BRDADOS-(\d{4,})")
          - first_group (opcional, default True): se True retorna o primeiro grupo captura; se False retorna o match inteiro
        """
        # normalizar nome da coluna fonte
        src = config.get("source_column")
        if isinstance(src, dict):
            src_col = src.get("column")
        else:
            src_col = src

        tgt_col = config.get("target_column") or config.get("target") or "Issue key"
        pattern = config.get("pattern")
        first_group = config.get("first_group", True)

        if src_col is None:
            # nada a fazer
            return df

        if src_col not in df.columns:
            # coluna não existe, cria coluna alvo com NaN e loga
            df[tgt_col] = np.nan
            # se tiver seu logger: WebScrapping.log(...)
            return df

        if not pattern:
            # sem pattern, cria coluna alvo vazia
            df[tgt_col] = np.nan
            return df

        try:
            # se há um grupo captura e first_group=True, extrair o grupo
            # usar pandas.extract (vetorizado) — lida bem com NaNs
            # detectar se pattern tem grupos
            n_groups = re.compile(pattern).groups
        except re.error:
            # pattern inválido: fallback -> coluna vazia
            df[tgt_col] = np.nan
            return df

        try:
            if first_group and n_groups >= 1:
                # extrai primeiro grupo — resultado será uma Series (primeira captura)
                extracted = df[src_col].astype("string").str.extract(pattern, expand=True)
                # se várias colunas (vários grupos), pegar a primeira
                if isinstance(extracted, pd.DataFrame):
                    # pega a primeira coluna do DataFrame de captura
                    ser = extracted.iloc[:, 0].astype("string")
                else:
                    ser = extracted.astype("string")
                # substituir strings vazias por NaN
                ser = ser.replace("", pd.NA)
                df[tgt_col] = ser.where(~ser.isna(), pd.NA)
            else:
                # se não há grupos ou first_group==False, extrair o match inteiro.
                # pandas não dispõe diretamente de 'match inteiro' via extract sem grupo, então usamos re.search por linha
                def find_full_match(val):
                    if pd.isna(val):
                        return pd.NA
                    m = re.search(pattern, str(val))
                    if not m:
                        return pd.NA
                    if first_group and m.groups():
                        return m.group(1)
                    else:
                        return m.group(0)
                df[tgt_col] = df[src_col].apply(find_full_match).astype("string")
                df[tgt_col] = df[tgt_col].replace("", pd.NA)

        except Exception:
            # fallback seguro: coluna target vazia
            df[tgt_col] = np.nan

        return df
